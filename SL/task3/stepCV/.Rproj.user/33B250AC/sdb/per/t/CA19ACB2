{
    "contents" : "---\ntitle: \"stepCV\"\nauthor: \"Karim Amanov\"\ndate: \"10 января 2015 г.\"\noutput: html_document\n---\n\nВозьмем код функции stepAIC из пакeта MASS и сделаем в нем нужные изменения. Кросс валидацию возьмем из e1071.\nЗаметим, что в stepAIC для подсчета значения AIC используется функция extractAIC. Давайте попробуем подметнить эту функцию, так чтобы значение считалось на основе CV\n```{r}\nlibrary(MASS)\nlibrary(e1071)\n\nmy_extractAIC <- function(fit, scale, k = 2, ...) UseMethod(\"my_extractAIC\")\n\ncv_method <- function(fit, m) {\n  t <- tune(m, fit$call$formula, data = eval(fit$call$data))\n  c(t$best.model$rank, t$best.performance)\n}\n\nmy_extractAIC.lm <- function(fit, scale, k = 2, ...){\n  cv_method(fit, lm)\n}\n\nmy_extractAIC.glm <- function(fit, scale, k = 2, ...){\n  cv_method(fit, glm)\n}\n\nmy_extractAIC.aov <- function(fit, scale, k = 2, ...){\n  cv_method(fit, aov)\n}\n```\n\nТеперь сделаем изменения в самой функции stepAIC\n\n```{r}\n\nstepCV <- function (object, scope, scale = 0, direction = c(\"both\", \"backward\", \n    \"forward\"), trace = 1, keep = NULL, steps = 1000, use.start = FALSE, \n    k = 2, ...) \n{\n    mydeviance <- function(x, ...) {\n        dev <- deviance(x)\n        if (!is.null(dev)) \n            dev\n        else my_extractAIC(x, k = 0, ...)[2L]\n    }\n    cut.string <- function(string) {\n        if (length(string) > 1L) \n            string[-1L] <- paste(\"\\n\", string[-1L], sep = \"\")\n        string\n    }\n    re.arrange <- function(keep) {\n        namr <- names(k1 <- keep[[1L]])\n        namc <- names(keep)\n        nc <- length(keep)\n        nr <- length(k1)\n        array(unlist(keep, recursive = FALSE), c(nr, nc), list(namr, \n            namc))\n    }\n    step.results <- function(models, fit, object, usingCp = FALSE) {\n        change <- sapply(models, \"[[\", \"change\")\n        rd <- sapply(models, \"[[\", \"deviance\")\n        dd <- c(NA, abs(diff(rd)))\n        rdf <- sapply(models, \"[[\", \"df.resid\")\n        ddf <- c(NA, abs(diff(rdf)))\n        AIC <- sapply(models, \"[[\", \"AIC\")\n        heading <- c(\"Stepwise Model Path \\nAnalysis of Deviance Table\", \n            \"\\nInitial Model:\", deparse(formula(object)), \"\\nFinal Model:\", \n            deparse(formula(fit)), \"\\n\")\n        aod <- if (usingCp) \n            data.frame(Step = change, Df = ddf, Deviance = dd, \n                `Resid. Df` = rdf, `Resid. Dev` = rd, Cp = AIC, \n                check.names = FALSE)\n        else data.frame(Step = change, Df = ddf, Deviance = dd, \n            `Resid. Df` = rdf, `Resid. Dev` = rd, AIC = AIC, \n            check.names = FALSE)\n        attr(aod, \"heading\") <- heading\n        class(aod) <- c(\"Anova\", \"data.frame\")\n        fit$anova <- aod\n        fit\n    }\n    Terms <- terms(object)\n    object$formula <- Terms\n    if (inherits(object, \"lme\")) \n        object$call$fixed <- Terms\n    else if (inherits(object, \"gls\")) \n        object$call$model <- Terms\n    else object$call$formula <- Terms\n    if (use.start) \n        warning(\"'use.start' cannot be used with R's version of 'glm'\")\n    md <- missing(direction)\n    direction <- match.arg(direction)\n    backward <- direction == \"both\" | direction == \"backward\"\n    forward <- direction == \"both\" | direction == \"forward\"\n    if (missing(scope)) {\n        fdrop <- numeric()\n        fadd <- attr(Terms, \"factors\")\n        if (md) \n            forward <- FALSE\n    }\n    else {\n        if (is.list(scope)) {\n            fdrop <- if (!is.null(fdrop <- scope$lower)) \n                attr(terms(update.formula(object, fdrop)), \"factors\")\n            else numeric()\n            fadd <- if (!is.null(fadd <- scope$upper)) \n                attr(terms(update.formula(object, fadd)), \"factors\")\n        }\n        else {\n            fadd <- if (!is.null(fadd <- scope)) \n                attr(terms(update.formula(object, scope)), \"factors\")\n            fdrop <- numeric()\n        }\n    }\n    models <- vector(\"list\", steps)\n    if (!is.null(keep)) \n        keep.list <- vector(\"list\", steps)\n    n <- nobs(object, use.fallback = TRUE)\n    fit <- object\n    bAIC <- my_extractAIC(fit, scale, k = k, ...)\n    edf <- bAIC[1L]\n    bAIC <- bAIC[2L]\n    if (is.na(bAIC)) \n        stop(\"AIC is not defined for this model, so 'stepAIC' cannot proceed\")\n    if (bAIC == -Inf) \n        stop(\"AIC is -infinity for this model, so 'stepAIC' cannot proceed\")\n    nm <- 1\n    Terms <- terms(fit)\n    if (trace) {\n        cat(\"Start:  AIC=\", format(round(bAIC, 2)), \"\\n\", cut.string(deparse(formula(fit))), \n            \"\\n\\n\", sep = \"\")\n        utils::flush.console()\n    }\n    models[[nm]] <- list(deviance = mydeviance(fit), df.resid = n - \n        edf, change = \"\", AIC = bAIC)\n    if (!is.null(keep)) \n        keep.list[[nm]] <- keep(fit, bAIC)\n    usingCp <- FALSE\n    while (steps > 0) {\n        steps <- steps - 1\n        AIC <- bAIC\n        ffac <- attr(Terms, \"factors\")\n        if (!is.null(sp <- attr(Terms, \"specials\")) && !is.null(st <- sp$strata)) \n            ffac <- ffac[-st, ]\n        scope <- factor.scope(ffac, list(add = fadd, drop = fdrop))\n        aod <- NULL\n        change <- NULL\n        if (backward && length(scope$drop)) {\n            aod <- dropterm(fit, scope$drop, scale = scale, trace = max(0, \n                trace - 1), k = k, ...)\n            rn <- row.names(aod)\n            row.names(aod) <- c(rn[1L], paste(\"-\", rn[-1L], sep = \" \"))\n            if (any(aod$Df == 0, na.rm = TRUE)) {\n                zdf <- aod$Df == 0 & !is.na(aod$Df)\n                nc <- match(c(\"Cp\", \"AIC\"), names(aod))\n                nc <- nc[!is.na(nc)][1L]\n                ch <- abs(aod[zdf, nc] - aod[1, nc]) > 0.01\n                if (any(is.finite(ch) & ch)) {\n                  warning(\"0 df terms are changing AIC\")\n                  zdf <- zdf[!ch]\n                }\n                if (length(zdf) > 0L) \n                  change <- rev(rownames(aod)[zdf])[1L]\n            }\n        }\n        if (is.null(change)) {\n            if (forward && length(scope$add)) {\n                aodf <- addterm(fit, scope$add, scale = scale, \n                  trace = max(0, trace - 1), k = k, ...)\n                rn <- row.names(aodf)\n                row.names(aodf) <- c(rn[1L], paste(\"+\", rn[-1L], \n                  sep = \" \"))\n                aod <- if (is.null(aod)) \n                  aodf\n                else rbind(aod, aodf[-1, , drop = FALSE])\n            }\n            attr(aod, \"heading\") <- NULL\n            if (is.null(aod) || ncol(aod) == 0) \n                break\n            nzdf <- if (!is.null(aod$Df)) \n                aod$Df != 0 | is.na(aod$Df)\n            aod <- aod[nzdf, ]\n            if (is.null(aod) || ncol(aod) == 0) \n                break\n            nc <- match(c(\"Cp\", \"AIC\"), names(aod))\n            nc <- nc[!is.na(nc)][1L]\n            o <- order(aod[, nc])\n            if (trace) {\n                print(aod[o, ])\n                utils::flush.console()\n            }\n            if (o[1L] == 1) \n                break\n            change <- rownames(aod)[o[1L]]\n        }\n        usingCp <- match(\"Cp\", names(aod), 0) > 0\n        fit <- update(fit, paste(\"~ .\", change), evaluate = FALSE)\n        fit <- eval.parent(fit)\n        nnew <- nobs(fit, use.fallback = TRUE)\n        if (all(is.finite(c(n, nnew))) && nnew != n) \n            stop(\"number of rows in use has changed: remove missing values?\")\n        Terms <- terms(fit)\n        bAIC <- my_extractAIC(fit, scale, k = k, ...)\n        edf <- bAIC[1L]\n        bAIC <- bAIC[2L]\n        if (trace) {\n            cat(\"\\nStep:  AIC=\", format(round(bAIC, 2)), \"\\n\", \n                cut.string(deparse(formula(fit))), \"\\n\\n\", sep = \"\")\n            utils::flush.console()\n        }\n        if (bAIC >= AIC + 1e-07) \n            break\n        nm <- nm + 1\n        models[[nm]] <- list(deviance = mydeviance(fit), df.resid = n - \n            edf, change = change, AIC = bAIC)\n        if (!is.null(keep)) \n            keep.list[[nm]] <- keep(fit, bAIC)\n    }\n    if (!is.null(keep)) \n        fit$keep <- re.arrange(keep.list[seq(nm)])\n    step.results(models = models[seq(nm)], fit, object, usingCp)\n}\n```\n\nПопробуем\n\n```{r}\nmodel <- lm(mpg ~ ., mtcars)\n\nmodel.aic <- stepAIC(model)\nmodel.cv <- stepCV(model)\n```\n\nНа то что в выводе AIC смотерть не стоит, формула все равно выводится исходя из значения нашей функции my_extractAIC (а в ней мы делаем cv)",
    "created" : 1420908584995.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3157369360",
    "id" : "CA19ACB2",
    "lastKnownWriteTime" : 1420914925,
    "path" : "~/Spbau/SL/task3/stepCV/stepCV.Rmd",
    "project_path" : "stepCV.Rmd",
    "properties" : {
        "tempName" : "Untitled2"
    },
    "source_on_save" : false,
    "type" : "r_markdown"
}